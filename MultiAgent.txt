!pip install transformers torch datasets pandas numpy tqdm matplotlib seaborn

import pandas as pd
import numpy as np
import torch
from transformers import AutoTokenizer, AutoModelForSequenceClassification
from tqdm import tqdm
import matplotlib.pyplot as plt
import seaborn as sns
from collections import defaultdict
import warnings
warnings.filterwarnings('ignore')

print("All libraries imported")
print(f"Device: {'GPU' if torch.cuda.is_available() else 'CPU'}")

from google.colab import files

print("Upload your Financial PhraseBank TXT files:")
uploaded = files.upload()

all_sentences = []
for fname in uploaded.keys():
    if fname.endswith(".txt"):
        with open(fname, "r", encoding="latin-1") as f:
            for line in f:
                line = line.strip()
                if line:
                    all_sentences.append(line)

def parse_line(text):
    original_label = None
    for tag in ["@positive", "@negative", "@neutral"]:
        if tag in text:
            original_label = tag.replace("@", "")
            text = text.replace(tag, "").strip()
            break
    return text, original_label

parsed = [parse_line(s) for s in all_sentences]
df = pd.DataFrame(parsed, columns=["headline", "original_label"])
df = df[df["headline"].str.len() > 10].reset_index(drop=True)

print(f"Loaded {len(df)} headlines")
print(df["original_label"].value_counts())

print("Loading FinBERT model...")

MODEL_NAME = "ProsusAI/finbert"
tokenizer = AutoTokenizer.from_pretrained(MODEL_NAME)
model = AutoModelForSequenceClassification.from_pretrained(MODEL_NAME)

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model = model.to(device)
model.eval()

print(f"FinBERT loaded on {device}")

INVESTOR_AGENTS = {
    "sarah_chen": {
        "name": "Sarah Chen",
        "age": 62,
        "occupation": "Retired Teacher",
        "portfolio_size": "$850,000",
        "risk_tolerance": 0.2,
        "optimism_bias": -0.1,
        "description": "Preserving retirement savings. Prefers stable dividends.",
        "reaction_style": "cautious"
    },
    "marcus_johnson": {
        "name": "Marcus Johnson",
        "age": 29,
        "occupation": "Software Engineer",
        "portfolio_size": "$45,000",
        "risk_tolerance": 0.8,
        "optimism_bias": 0.15,
        "description": "Aggressive growth. Heavy in tech and crypto.",
        "reaction_style": "aggressive"
    },
    "david_kumar": {
        "name": "David Kumar",
        "age": 45,
        "occupation": "Financial Analyst",
        "portfolio_size": "$1.2M",
        "risk_tolerance": 0.5,
        "optimism_bias": 0.0,
        "description": "Data-driven value investor.",
        "reaction_style": "analytical"
    },
    "jennifer_oconnor": {
        "name": "Jennifer O'Connor",
        "age": 38,
        "occupation": "Marketing Director",
        "portfolio_size": "$320,000",
        "risk_tolerance": 0.6,
        "optimism_bias": 0.1,
        "description": "Balanced. Believes in long-term growth.",
        "reaction_style": "balanced"
    },
    "robert_tanaka": {
        "name": "Robert Tanaka",
        "age": 55,
        "occupation": "Small Business Owner",
        "portfolio_size": "$680,000",
        "risk_tolerance": 0.35,
        "optimism_bias": -0.05,
        "description": "Conservative growth. Wants steady returns.",
        "reaction_style": "moderate"
    },
    "emily_wright": {
        "name": "Emily Wright",
        "age": 24,
        "occupation": "Graduate Student",
        "portfolio_size": "$12,000",
        "risk_tolerance": 0.7,
        "optimism_bias": 0.2,
        "description": "New investor. Follows trends closely.",
        "reaction_style": "reactive"
    },
    "michael_santos": {
        "name": "Michael Santos",
        "age": 52,
        "occupation": "Hedge Fund Manager",
        "portfolio_size": "$15M (fund)",
        "risk_tolerance": 0.65,
        "optimism_bias": -0.1,
        "description": "Professional contrarian.",
        "reaction_style": "contrarian"
    },
    "lisa_patel": {
        "name": "Lisa Patel",
        "age": 41,
        "occupation": "Doctor",
        "portfolio_size": "$920,000",
        "risk_tolerance": 0.45,
        "optimism_bias": 0.05,
        "description": "Busy professional. Prefers index funds.",
        "reaction_style": "passive"
    }
}

print(f"{len(INVESTOR_AGENTS)} investors defined")
for a in INVESTOR_AGENTS.values():
    print(f"  {a['name']}, {a['age']} - {a['occupation']}")

def get_finbert_sentiment(texts, batch_size=32):
    all_results = []
    
    for i in tqdm(range(0, len(texts), batch_size), desc="Analyzing"):
        batch = texts[i:i+batch_size]
        
        inputs = tokenizer(batch, padding=True, truncation=True, 
                          max_length=512, return_tensors="pt").to(device)
        
        with torch.no_grad():
            outputs = model(**inputs)
            probs = torch.softmax(outputs.logits, dim=1).cpu().numpy()
        
        for prob in probs:
            all_results.append({
                "positive": float(prob[0]),
                "negative": float(prob[1]),
                "neutral": float(prob[2]),
                "sentiment_score": float(prob[0] - prob[1])
            })
    
    return all_results


def agent_decision(sentiment_result, agent_profile):
    base_score = sentiment_result["sentiment_score"]
    risk_tolerance = agent_profile["risk_tolerance"]
    optimism_bias = agent_profile["optimism_bias"]
    style = agent_profile["reaction_style"]
    
    adjusted_score = base_score + optimism_bias
    
    if style == "contrarian":
        adjusted_score = -adjusted_score * 0.5
    elif style == "reactive":
        adjusted_score = adjusted_score * 1.3
    elif style == "passive":
        adjusted_score = adjusted_score * 0.6
    elif style == "cautious":
        if adjusted_score < 0:
            adjusted_score = adjusted_score * 1.4
    elif style == "aggressive":
        if adjusted_score > 0:
            adjusted_score = adjusted_score * 1.3
    
    adjusted_score = max(-1, min(1, adjusted_score))
    
    if adjusted_score > 0.15:
        sentiment_label = "positive"
    elif adjusted_score < -0.15:
        sentiment_label = "negative"
    else:
        sentiment_label = "neutral"
    
    action_threshold = 0.3 * (1 - risk_tolerance) + 0.1
    
    if adjusted_score > action_threshold:
        action = "buy"
    elif adjusted_score < -action_threshold:
        action = "sell"
    else:
        action = "hold"
    
    if risk_tolerance < 0.3 and action != "hold":
        if abs(adjusted_score) < 0.4:
            action = "hold"
    
    confidence = min(10, max(1, abs(adjusted_score) * 10 * (0.7 + risk_tolerance * 0.3)))
    
    return {
        "sentiment": sentiment_label,
        "action": action,
        "confidence": round(confidence, 1),
        "adjusted_score": round(adjusted_score, 3)
    }

SAMPLE_SIZE = 8000

if SAMPLE_SIZE and SAMPLE_SIZE < len(df):
    sample_df = df.sample(n=SAMPLE_SIZE, random_state=42).reset_index(drop=True)
else:
    sample_df = df.copy()

print(f"Analyzing {len(sample_df)} headlines x {len(INVESTOR_AGENTS)} agents...")

headlines_list = sample_df["headline"].tolist()
sentiment_results = get_finbert_sentiment(headlines_list)

all_agent_results = []
for idx, (headline, sentiment) in enumerate(tqdm(zip(headlines_list, sentiment_results), 
                                                   total=len(headlines_list))):
    original_label = sample_df.iloc[idx]["original_label"]
    
    for agent_id, agent_profile in INVESTOR_AGENTS.items():
        decision = agent_decision(sentiment, agent_profile)
        
        all_agent_results.append({
            "headline_id": idx,
            "headline": headline,
            "original_label": original_label,
            "finbert_score": sentiment["sentiment_score"],
            "agent_id": agent_id,
            "agent_name": agent_profile["name"],
            "agent_sentiment": decision["sentiment"],
            "agent_action": decision["action"],
            "agent_confidence": decision["confidence"]
        })

results_df = pd.DataFrame(all_agent_results)
print(f"Done! {len(results_df)} total decisions")

fig, axes = plt.subplots(2, 3, figsize=(18, 12))
fig.suptitle("Multi-Agent Sentiment Analysis", fontsize=16, fontweight='bold')

sentiment_colors = {"positive": "#2ecc71", "neutral": "#3498db", "negative": "#e74c3c"}
action_colors = {"buy": "#27ae60", "hold": "#f39c12", "sell": "#c0392b"}

ax1 = axes[0, 0]
counts = results_df["agent_sentiment"].value_counts()
ax1.bar(counts.index, counts.values, color=[sentiment_colors[s] for s in counts.index])
ax1.set_title("Overall Sentiment")

ax2 = axes[0, 1]
counts = results_df["agent_action"].value_counts()
ax2.bar(counts.index, counts.values, color=[action_colors[a] for a in counts.index])
ax2.set_title("Overall Actions")

ax3 = axes[0, 2]
pivot = results_df.groupby(["agent_name", "agent_sentiment"]).size().unstack(fill_value=0)
pivot = pivot.reindex(columns=["positive", "neutral", "negative"], fill_value=0)
pivot.plot(kind="barh", stacked=True, ax=ax3, 
           color=[sentiment_colors["positive"], sentiment_colors["neutral"], 
                  sentiment_colors["negative"]])
ax3.set_title("Sentiment by Investor")

ax4 = axes[1, 0]
pivot = results_df.groupby(["agent_name", "agent_action"]).size().unstack(fill_value=0)
pivot = pivot.reindex(columns=["buy", "hold", "sell"], fill_value=0)
pivot.plot(kind="barh", stacked=True, ax=ax4,
           color=[action_colors["buy"], action_colors["hold"], action_colors["sell"]])
ax4.set_title("Actions by Investor")

ax5 = axes[1, 1]
conf = results_df.groupby("agent_name")["agent_confidence"].mean().sort_values()
conf.plot(kind="barh", ax=ax5, color="purple")
ax5.set_title("Avg Confidence")
ax5.set_xlim(0, 10)

ax6 = axes[1, 2]
hm = results_df.groupby(["agent_sentiment", "agent_action"]).size().unstack(fill_value=0)
sns.heatmap(hm, annot=True, fmt="d", cmap="YlOrRd", ax=ax6)
ax6.set_title("Sentiment to Action")

plt.tight_layout()
plt.savefig("charts.png", dpi=150)
plt.show()

print("=" * 60)
print("INVESTOR BEHAVIOR REPORT")
print("=" * 60)

for agent_id, profile in INVESTOR_AGENTS.items():
    data = results_df[results_df["agent_id"] == agent_id]
    
    print(f"{profile['name']}, {profile['age']} - {profile['occupation']}")
    print(f"   Risk: {profile['risk_tolerance']:.0%} | \"{profile['description']}\"")
    
    sent_pct = data["agent_sentiment"].value_counts(normalize=True) * 100
    print(f"   Sentiment: Pos {sent_pct.get('positive',0):.0f}% | Neu {sent_pct.get('neutral',0):.0f}% | Neg {sent_pct.get('negative',0):.0f}%")
    
    act_pct = data["agent_action"].value_counts(normalize=True) * 100
    print(f"   Actions:   Buy {act_pct.get('buy',0):.0f}% | Hold {act_pct.get('hold',0):.0f}% | Sell {act_pct.get('sell',0):.0f}%")
    print()

print("=" * 60)
print("AGREEMENT ANALYSIS")
print("=" * 60)

agreement_data = []
for hid in results_df["headline_id"].unique():
    group = results_df[results_df["headline_id"] == hid]
    sents = group["agent_sentiment"].tolist()
    agreement = max(sents.count(s) for s in set(sents)) / len(sents)
    agreement_data.append({
        "headline_id": hid, 
        "agreement": agreement, 
        "headline": group["headline"].iloc[0]
    })

agreement_df = pd.DataFrame(agreement_data)

print(f"Average Agreement: {agreement_df['agreement'].mean():.1%}")
print(f"Full Consensus Headlines: {(agreement_df['agreement'] == 1.0).sum()}")

print("\nMost Controversial Headlines (lowest agreement):")
for _, row in agreement_df.nsmallest(3, "agreement").iterrows():
    print(f"  \"{row['headline'][:60]}...\" ({row['agreement']:.0%} agree)")

results_df.to_csv("agent_results.csv", index=False)
agreement_df.to_csv("agreement.csv", index=False)

from google.colab import files
files.download("agent_results.csv")
files.download("agreement.csv")
files.download("charts.png")

print("\nFiles downloaded!")
